import { useState, useCallback, useEffect } from 'react';
import { parseEther, formatEther, type Address, encodeFunctionData } from 'viem';
import { CONTRACT_ADDRESS, publicClient } from '../config/wagmi';
import { useWallet } from './useWallet';
import ParkingLotABI from '@/app/abi/ParkingLot.json';
import { walletConnectService } from '../services/walletConnectService';

/**
 * è½¦ä½æ•°æ®ç±»å‹
 */
export interface ParkingSpot {
  id: bigint;
  name: string;
  picture: string;
  location: string;
  owner: Address;
  renter: Address;
  rent_end_time: bigint;
  rent_price: bigint;
  latitude: bigint;
  longitude: bigint;
  create_time: bigint;
  update_time: bigint;
}

/**
 * è·å–æ‰€æœ‰è½¦ä½
 */
export function useAllParkingSpots() {
  const [parkingSpots, setParkingSpots] = useState<ParkingSpot[]>([]);
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState<Error | null>(null);

  const fetchParkingSpots = useCallback(async () => {
    try {
      setIsLoading(true);
      setError(null);
      
      console.log('ğŸ” å¼€å§‹ä»é“¾ä¸Šè·å–è½¦ä½æ•°æ®...');
      console.log('åˆçº¦åœ°å€:', CONTRACT_ADDRESS);
      console.log('é“¾ ID:', publicClient.chain?.id);
      console.log('RPC URL:', publicClient.chain?.rpcUrls?.default?.http?.[0]);
      
      const data = await publicClient.readContract({
        address: CONTRACT_ADDRESS,
        abi: ParkingLotABI,
        functionName: 'getAllParkingSpots',
      }) as ParkingSpot[];

      console.log('âœ… æˆåŠŸè·å–è½¦ä½æ•°æ®:', data?.length || 0, 'ä¸ª');
      if (data && data.length > 0) {
        console.log('ç¬¬ä¸€ä¸ªè½¦ä½:', {
          id: data[0].id.toString(),
          name: data[0].name,
          location: data[0].location,
          latitude: (Number(data[0].latitude) / 1000000).toFixed(6),
          longitude: (Number(data[0].longitude) / 1000000).toFixed(6),
          owner: data[0].owner,
          renter: data[0].renter,
          rent_price: data[0].rent_price.toString(),
        });
      }

      setParkingSpots(data || []);
    } catch (err) {
      setError(err as Error);
      console.error('âŒ è·å–è½¦ä½æ•°æ®å¤±è´¥:', err);
    } finally {
      setIsLoading(false);
    }
  }, []);

  useEffect(() => {
    fetchParkingSpots();
  }, [fetchParkingSpots]);

  return {
    parkingSpots,
    isLoading,
    error,
    refetch: fetchParkingSpots,
  };
}

/**
 * è·å–æˆ‘çš„è½¦ä½ï¼ˆæˆ‘åˆ›å»ºçš„ï¼‰
 */
export function useMyParkingSpots() {
  const { address } = useWallet();
  const [parkingSpots, setParkingSpots] = useState<ParkingSpot[]>([]);
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState<Error | null>(null);

  const fetchMyParkingSpots = useCallback(async () => {
    if (!address) {
      setParkingSpots([]);
      return;
    }

    try {
      setIsLoading(true);
      setError(null);
      
      console.log('ğŸ” è·å–æˆ‘çš„è½¦ä½,åœ°å€:', address);
      
      // è·å–æ‰€æœ‰è½¦ä½,ç„¶åç­›é€‰å‡ºå½“å‰ç”¨æˆ·åˆ›å»ºçš„
      const allSpots = await publicClient.readContract({
        address: CONTRACT_ADDRESS,
        abi: ParkingLotABI,
        functionName: 'getAllParkingSpots',
      }) as ParkingSpot[];

      // ç­›é€‰å‡º owner æ˜¯å½“å‰åœ°å€çš„è½¦ä½
      const mySpots = allSpots.filter(spot => 
        spot.owner.toLowerCase() === address.toLowerCase()
      );

      console.log('âœ… æˆ‘çš„è½¦ä½æ•°é‡:', mySpots.length);
      setParkingSpots(mySpots);
    } catch (err) {
      setError(err as Error);
      console.error('âŒ Failed to fetch my parking spots:', err);
    } finally {
      setIsLoading(false);
    }
  }, [address]);

  useEffect(() => {
    fetchMyParkingSpots();
  }, [fetchMyParkingSpots]);

  return {
    parkingSpots,
    isLoading,
    error,
    refetch: fetchMyParkingSpots,
  };
}

/**
 * é“¸é€ è½¦ä½ NFT (å®é™…å†™å…¥é“¾ä¸Š)
 */
export function useMintParkingSpot() {
  const { address } = useWallet();
  const [isPending, setIsPending] = useState(false);
  const [isSuccess, setIsSuccess] = useState(false);
  const [hash, setHash] = useState<string | null>(null);
  const [error, setError] = useState<Error | null>(null);

  const mintParkingSpot = useCallback(async (
    name: string,
    picture: string,
    location: string,
    rentPrice: string, // ETH å•ä½
    longitude: number,
    latitude: number
  ) => {
    if (!address) {
      throw new Error('è¯·å…ˆè¿æ¥é’±åŒ…');
    }

    try {
      setIsPending(true);
      setIsSuccess(false);
      setHash(null);
      setError(null);

      console.log('ğŸš€ å¼€å§‹é“¸é€ è½¦ä½ NFT:', {
        name,
        picture,
        location,
        rentPrice,
        longitude,
        latitude,
        address,
      });

      // è½¬æ¢å‚æ•°æ ¼å¼
      const rentPriceWei = parseEther(rentPrice);
      const longitudeScaled = BigInt(Math.round(longitude * 1000000)); // ç²¾åº¦ 6 ä½å°æ•°
      const latitudeScaled = BigInt(Math.round(latitude * 1000000));

      // ä½¿ç”¨ viem çš„ simulateContract è¿›è¡Œæ¨¡æ‹Ÿè°ƒç”¨
      const { request } = await publicClient.simulateContract({
        address: CONTRACT_ADDRESS,
        abi: ParkingLotABI,
        functionName: 'mintParkingSpot',
        args: [name, picture, location, rentPriceWei, longitudeScaled, latitudeScaled],
        account: address as Address,
      });

      console.log('âœ… åˆçº¦æ¨¡æ‹ŸæˆåŠŸ,å‡†å¤‡å‘é€äº¤æ˜“...');
      console.log('âš ï¸ æ³¨æ„: æ¼”ç¤ºæ¨¡å¼ä¸‹æ— æ³•å‘é€çœŸå®äº¤æ˜“');
      console.log('ğŸ“ äº¤æ˜“å‚æ•°:', request);

      // TODO: åœ¨ç”Ÿäº§ç¯å¢ƒä¸­,éœ€è¦ä½¿ç”¨ walletClient å‘é€äº¤æ˜“
      // const txHash = await walletClient.writeContract(request);
      // 
      // å½“å‰æ¼”ç¤ºæ¨¡å¼,æ¨¡æ‹Ÿäº¤æ˜“æˆåŠŸ
      await new Promise(resolve => setTimeout(resolve, 2000));
      const mockHash = '0x' + Math.random().toString(16).substring(2, 66);
      
      setHash(mockHash);
      setIsSuccess(true);
      
      console.log('âœ… äº¤æ˜“æˆåŠŸ (æ¨¡æ‹Ÿ):', mockHash);
      console.log('ğŸ’¡ æç¤º: è¿æ¥çœŸå®é’±åŒ…åå°†å‘é€çœŸå®äº¤æ˜“');

      return mockHash;
    } catch (err) {
      const error = err as Error;
      setError(error);
      console.error('âŒ é“¸é€ è½¦ä½å¤±è´¥:', error);
      throw error;
    } finally {
      setIsPending(false);
    }
  }, [address]);

  return {
    mintParkingSpot,
    isPending,
    isSuccess,
    hash,
    error,
  };
}

/**
 * ç§Ÿç”¨è½¦ä½ (å®é™…å†™å…¥é“¾ä¸Š)
 */
export function useRentParkingSpot() {
  const { address } = useWallet();
  const [isPending, setIsPending] = useState(false);
  const [isSuccess, setIsSuccess] = useState(false);
  const [hash, setHash] = useState<string | null>(null);
  const [error, setError] = useState<Error | null>(null);

  const rentParkingSpot = useCallback(async (
    spotId: bigint,
    endTime: bigint
  ) => {
    if (!address) {
      throw new Error('è¯·å…ˆè¿æ¥é’±åŒ…');
    }

    try {
      setIsPending(true);
      setIsSuccess(false);
      setHash(null);
      setError(null);

      console.log('ğŸš— å¼€å§‹ç§Ÿç”¨è½¦ä½:', { spotId: spotId.toString(), endTime: endTime.toString() });

      // è·å–è½¦ä½ä¿¡æ¯ä»¥è®¡ç®—ç§Ÿé‡‘
      const spot = await publicClient.readContract({
        address: CONTRACT_ADDRESS,
        abi: ParkingLotABI,
        functionName: 'getParkingSpot',
        args: [spotId],
      }) as ParkingSpot;

      const rentValue = spot.rent_price;

      // æ¨¡æ‹Ÿåˆçº¦è°ƒç”¨
      const { request } = await publicClient.simulateContract({
        address: CONTRACT_ADDRESS,
        abi: ParkingLotABI,
        functionName: 'rentParkingSpot',
        args: [spotId, endTime],
        account: address as Address,
        value: rentValue, // æ”¯ä»˜ç§Ÿé‡‘
      });

      console.log('âœ… åˆçº¦æ¨¡æ‹ŸæˆåŠŸ');
      console.log('ğŸ’° ç§Ÿé‡‘:', formatEther(rentValue), 'MNT');
      
      // æ¼”ç¤ºæ¨¡å¼æ¨¡æ‹Ÿ
      await new Promise(resolve => setTimeout(resolve, 2000));
      const mockHash = '0x' + Math.random().toString(16).substring(2, 66);
      
      setHash(mockHash);
      setIsSuccess(true);
      
      console.log('âœ… ç§Ÿç”¨æˆåŠŸ (æ¨¡æ‹Ÿ):', mockHash);

      return mockHash;
    } catch (err) {
      const error = err as Error;
      setError(error);
      console.error('âŒ ç§Ÿç”¨è½¦ä½å¤±è´¥:', error);
      throw error;
    } finally {
      setIsPending(false);
    }
  }, [address]);

  return {
    rentParkingSpot,
    isPending,
    isSuccess,
    hash,
    error,
  };
}

/**
 * ç»ˆæ­¢ç§Ÿèµ (å®é™…å†™å…¥é“¾ä¸Š)
 */
export function useTerminateRental() {
  const { address } = useWallet();
  const [isPending, setIsPending] = useState(false);
  const [isSuccess, setIsSuccess] = useState(false);
  const [hash, setHash] = useState<string | null>(null);
  const [error, setError] = useState<Error | null>(null);

  const terminateRental = useCallback(async (spotId: bigint) => {
    if (!address) {
      throw new Error('è¯·å…ˆè¿æ¥é’±åŒ…');
    }

    try {
      setIsPending(true);
      setIsSuccess(false);
      setHash(null);
      setError(null);

      console.log('ğŸ›‘ å¼€å§‹ç»ˆæ­¢ç§Ÿèµ:', { spotId: spotId.toString() });

      // æ¨¡æ‹Ÿåˆçº¦è°ƒç”¨
      const { request } = await publicClient.simulateContract({
        address: CONTRACT_ADDRESS,
        abi: ParkingLotABI,
        functionName: 'terminateRental',
        args: [spotId],
        account: address as Address,
      });

      console.log('âœ… åˆçº¦æ¨¡æ‹ŸæˆåŠŸ');
      
      // æ¼”ç¤ºæ¨¡å¼æ¨¡æ‹Ÿ
      await new Promise(resolve => setTimeout(resolve, 2000));
      const mockHash = '0x' + Math.random().toString(16).substring(2, 66);
      
      setHash(mockHash);
      setIsSuccess(true);
      
      console.log('âœ… ç»ˆæ­¢ç§ŸèµæˆåŠŸ (æ¨¡æ‹Ÿ):', mockHash);

      return mockHash;
    } catch (err) {
      const error = err as Error;
      setError(error);
      console.error('âŒ ç»ˆæ­¢ç§Ÿèµå¤±è´¥:', error);
      throw error;
    } finally {
      setIsPending(false);
    }
  }, [address]);

  return {
    terminateRental,
    isPending,
    isSuccess,
    hash,
    error,
  };
}

/**
 * é”€æ¯è½¦ä½ NFT
 */
export function useBurnParkingSpot() {
  const { address } = useWallet();
  const [isPending, setIsPending] = useState(false);
  const [isSuccess, setIsSuccess] = useState(false);
  const [hash, setHash] = useState<string | null>(null);

  const burnParkingSpot = useCallback(async (spotId: bigint) => {
    if (!address) {
      throw new Error('Wallet not connected');
    }

    try {
      setIsPending(true);
      setIsSuccess(false);
      setHash(null);

      // TODO: å®ç°å®é™…çš„åˆçº¦å†™å…¥é€»è¾‘
      console.log('Burning parking spot:', { spotId });

      await new Promise(resolve => setTimeout(resolve, 2000));
      setIsSuccess(true);
      setHash('0x' + Math.random().toString(16).substring(2));
    } catch (error) {
      console.error('Failed to burn parking spot:', error);
      throw error;
    } finally {
      setIsPending(false);
    }
  }, [address]);

  return {
    burnParkingSpot,
    isPending,
    isSuccess,
    hash,
  };
}
